모듈 1에 오신 것을 환영합니다. 
코드를 깊게 들여다보기 전에, LandGraph에 대한 간단한 동기를 설명하고 전체 과정의 로드맵을 제공하려 합니다. 
이렇게 함으로써 어떤 것들을 기대해야 하는지 감을 잡을 수 있을 것입니다. 
첫째로, 단독 언어 모델만으로는 다소 제한적입니다. 도구, 외부 컨텍스트(예: 문서화) 등에 접근할 수 없으며, 복수 단계의 작업 흐름을 수행할 수 없습니다. 
그래서 많은 LLM 응용 프로그램은 LLM 호출 전후 단계에 어떤 종류의 제어 흐름을 사용합니다. 이것은 도구 호출일 수도 있고, 검색 단계일 수도 있습니다. 이 제어 흐름은 체인을 형성합니다. 체인이라는 용어를 들어 보셨을 것입니다. 
이것을 LLM 호출 전후의 일련의 단계 집합으로 생각할 수 있습니다. 체인의 장점은 매우 신뢰성이 있다는 것입니다. 즉, 체인을 호출할 때마다 동일한 흐름의 단계가 발생합니다. 
하지만 우리는 특정 종류의 문제에 대해 자체 제어 흐름을 선택할 수 있는 LLM 시스템이 필요합니다. LLM 응용 프로그램이 직면한 문제에 따라 자신의 단계 집합을 선택할 수 있게 하고 싶을 수 있습니다. 
이것이 바로 에이전트의 개념입니다. 
간단하게 정의하면, 에이전트는 LLM에 의해 정의된 제어 흐름입니다. 따라서 개발자가 정한 고정된 제어 흐름인 체인과 LLM에 의해 정의된 제어 흐름인 에이전트가 있습니다. 
여기서 흥미로운 점은 에이전트가 다양한 형태를 가질 수 있다는 것입니다. LLM에게 얼마나 많은 제어 권한을 부여하는지의 정도를 낮은 단계에서 높은 단계로 조정할 수 있습니다. 
낮은 단계에서는 라우터 같은 것을 생각할 수 있습니다. 이는 LLM이 흐름 내의 단일 단계를 제어하고, 좁은 범위의 옵션 중에서 선택할 수 있습니다. 이 토이 예시에서는 LLM의 결정에 따라 1단계에서 2단계 또는 3단계로 이동합니다.
 반면에, 완전 자율적인 에이전트는 주어진 옵션 중에서 어떤 단계의 순서든지 선택할 수 있거나, 심지어 특정일 수 있는 리소스에 따라 자신의 단계를 생성할 수도 있습니다. 그래서 자신의 다음 행동을 자동 생성할 수도 있습니다.



사용 가능한 자원들이 있습니다. 하지만, 그에 대한 실질적인 도전이 존재합니다. 우리는 애플리케이션의 신뢰성을 y축에, LLM에게 주는 제어 수준을 x축에 놓고 생각할 수 있습니다. 
일반적으로, 우리가 LLM에게 주는 제어 수준을 높일수록 신뢰성이 떨어집니다. 그래서 라우터 같이 간단한 것에서 완전히 자율적인 에이전트와 같은 복잡한 것으로 넘어가면, 애플리케이션의 신뢰성이 저하됩니다. 
따라서, 이것이 Landgraf의 동기를 설정하는 것입니다. Landgraf는 이 신뢰성 곡선을 굽히는데 도움이 될 것으로, 신뢰성을 유지하면서도 LLM 혹은 에이전트에게 주는 제어 수준을 밀어내는 에이전트를 개발할 수 있게 합니다. 

우리는 많은 애플리케이션에서 개발자의 직관과 LLM의 제어를 결합하고자 합니다. 따라서, 고정적으로 항상 실행하고 싶은 애플리케이션의 과정을 쉽게 지정할 수 있습니다. 
그러나 LLM을 아무때나 가변적으로 삽입할 수도 있으며, LLM에게 애플리케이션의 흐름을 자유롭게 제어할 수 있도록 할 수 있습니다. 

이것들은 그래프로 표현됩니다. 그래프는 노드와 에지로 이루어져 있으며, 노드는 애플리케이션의 과정을 나타내며, 에지는 노드 간의 연결성을 표현합니다. 
노드와 에지를 어떻게 레이아웃하는지에 대해 많은 유연성이 있습니다. 

Landgraph에는 몇 가지 구조적인 특성들이 있습니다. 
이는 지속성, 스트리밍, 인간 루프, 그리고 고급 제어 기능 등을 포함하며, 이들은 이 강의의 모듈의 핵심 요소들입니다. 이에 대해 상세하게 다룰 예정입니다.



LandGraph는 IDE도 함께 제공하므로, 개발하고 있는 에이전트를 디버그하고 시각화하는 데 사용할 수 있는 시각적 환경을 제공합니다. 
이를 자주 사용하게 될 것이며, 이는 매우 유용한 디버깅 및 관찰 도구임을 알게 될 것입니다. LandGraph가 LangChain과 매우 자연스럽게 잘 작동한다는 것을 강조하고 싶습니다. 
LangChain은 또한 오픈 소스 라이브러리로, 특히 다양한 LLM 통합, 벡터 스토어 통합 등과 같은 많은 다른 통합을 가지고 있습니다. LandGraph 워크플로우 내에서 이들 LangChain 컴포넌트를 자주 사용합니다.
가장 간단한 예를 들어 보겠습니다. 
벡터 스토어에서 검색 단계가 있고, 검색된 문서를 가지고 질문에 대답하는 LLM 단계가 있는 '검색 증강 생성(Retriever Augmented Generation)' 장난감 애플리케이션을 보여주고 있습니다. 
검색기는 벡터 스토어일 수 있으며, LangChain의 벡터 스토어를 사용할 수 있습니다. 또한, LLM 노드는 LangChain의 LLM 통합을 사용할 수 있지만, 반드시 그럴 필요는 없습니다. LandGraph를 사용하려면 반드시 LangChain을 사용해야 하는 것은 아닙니다. 
그러나 이 과정에서 LangChain을 자주 사용하게 될 것이며, LLM 상호 운용성 측면에서 특히 좋은 기능을 제공함을 알게 될 것입니다. 
LangChain은 LLM을 호출하는 공통 인터페이스와 일련의 메소드를 제공하는데, 이는 모델을 아주 쉽게 교체할 수 있게 해줍니다.
그러나 LandGraph와 함께 반드시 LangChain을 사용해야 하는 것은 아닙니다. 이 두 가지가 매우 잘 작동함을 강조하고 싶지만, 반드시 LangChain을 사용해야 하는 것은 아닙니다.


우리가 여기서 어떤 일을 할지 전체적인 구도를 제시해보겠습니다. 
첫 번째 모듈에서는 기초를 다지는 과정입니다. LineGraph Studio를 소개하고, LineGraph의 핵심 개념들을 소개할 것입니다. 
그리고 우리는 router와 일반 tool-calling agent라는 두 개의 흥미로운 에이전트 아키텍처를 구축할 것입니다. 이렇게 LineGraph Studio에서 이 작은 다이어그램들을 볼 수 있습니다. 
따라서 첫 번째 모듈이 끝날 때 쯤에는 두 가지 다른 에이전트 아키텍처를 만들고, Studio를 시작하고, LineGraph가 어떻게 동작하는지 기본적인 부분을 알게 될 것입니다.

두 번째 모듈에서는 데이터 저장 기능을 더 심도 있게 다루게 됩니다. 챗봇을 구축하며 오랜 시간 동안 대화를 계속할 수 있게 기억력을 갖춘 챗봇을 만들 것입니다. 이 과정에서는 LineGraph에서 어떻게 데이터를 지속적으로 저장하고 기억하는지를 배울 수 있습니다.

세 번째 모듈에서는 사용자 참여 과정을 넣습니다. 사용자가 도구 호출 프로세스에 승인을 하거나 LineGraph 에이전트의 상태를 편집하는 등의 기능을 추가하게 됩니다. 이 과정에서 스트리밍하는 방법도 소개되게 됩니다.

마지막으로, 네 번째 모듈은 모든 요소들을 함께 결합하여 복잡한 연구 보조 도구를 만들어봅니다. 이 도구는 사용자 참여 기능, 다양한 병렬화 기능(예: MapReduce), 스트리밍 기능, 그리고 데이터 저장 및 기억 기능 등을 활용할 것입니다.

첫 세 모듈은 기초적인 내용을 다루는데, 이를 위해 라우터 및 도구 호출 에이전트, 채팅봇, 그리고 사용자 참여가 포함된 도구 호출 에이전트 등 다양한 에이전트 아키텍처를 개발하게 됩니다. 
좀 더 고급 사용자의 경우 이들 모듈을 빠르게 진행하고 복잡한 총체적인 에이전트를 개발하는 네 번째 모듈로 바로 이동할 수 있습니다. 기초를 확실히 이해하고 싶다면 1-3 모듈에 좀 더 시간을 투자할 수 있습니다. 
이런 방식으로 전반적인 로드맵을 제공하려 하므로 이를 바탕으로 앞으로의 과정을 진행해보시면 좋을 것 같습니다. 이제 코드 작업으로 들어가 보겠습니다.






